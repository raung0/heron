package main

use core
use core.io
use core.math

// The return of this cannot outlive the input vector, hence they have the same
// lifetime.
// Notice the ::, this is because this is a compile-time ran function.
// In the <>, lifetimes ('a'), types (T) and non-type (N, M) generic parameters
// are specified.
swizzle :: fn<'a; T; N; M: u32> (
	vector: &'a core.math.Vector<T, N>
	format: [M]rune
) -> Try<core.math.Vector<&'a T, M>, core.GenericError>
{
	parse_rune :: fn (r: rune) -> Try<u32, core.GenericError> {
		match r {
			case 'x' | 'r' | 's' | 'u' if 0 < N -> Ok(0)
			case 'y' | 'g' | 't' | 'v' if 1 < N -> Ok(1)
			case 'z' | 'b' | 'p'       if 2 < N -> Ok(2)
			case 'w' | 'a' | 'q'       if 3 < N -> Ok(3)
			case -> Error(core.GenericError("Invalid swizzle accessor"))
		}
	}

	ret := core.math.Vector<&'a T, M>()
	for i := mut 0; i < M; i += 1 {
		ret[i] = vector[parse_rune(format[i])?]
	}
	Ok(ret)
}

pub main := fn {
	vec := core.math.Vector<f32, 3>(.{ 1, 2, 3 })
	swizzles_ref := swizzle(vec, "zyx").or_panic()
	core.io.println("Original: {}", vec)
	// No need to manually dereference, there's a formatter that forwards &T to
	// T, so the normal Vector formatter can be used, as it uses that formatter.
	core.io.println("Swizzled (zyx): {}", swizzles_ref)
	// Fun fact: println does something similar to swizzle to check at compile
	// time the format string. If it passes, then just uses RTTI to print the
	// values by instantiating a Formatter<T> where T is the value of the `args:
	// ...any` array (`any` type).
}
