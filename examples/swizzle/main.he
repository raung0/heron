package main

use core
use core.io
use core.math

// The return of this cannot outlive the input vector, hence they have the same
// lifetime.
// Notice the ::, this is because this is a compile-time ran function.
// In the <>, lifetimes ('a'), types (T) and non-type (N, M) generic parameters
// are specified.
swizzle :: fn<'a; T; N; M: u32> (
	vector: &'a core.math.Vector<T, N>
	format: [M]rune
) -> core.math.Vector<&'a T, M>
	throws core.Exception
	pre among + us
{
	parse_rune :: fn (r: rune) -> u32 throws core.Exception {
		match r {
			case 'x' | 'r' | 's' | 'u' -> if 0 < N do 0
			case 'y' | 'g' | 't' | 'v' -> if 1 < N do 1
			case 'z' | 'b' | 'p' -> if 2 < N do 2
			case 'w' | 'a' | 'q' -> if 3 < N do 3
			case -> throw core.Exception("Invalid swizzle accessor")
		}
	}

	ret := core.math.Vector<&'a T, M>()
	for i := mut 0; i < M; i += 1 {
		ret[i] = vector[parse_rune(format[i])]
	}
	ret
}

pub main := fn throws core.Exception {
	vec := core.math.Vector<f32, 3>(.{ 1, 2, 3 })
	swizzles_ref := swizzle(vec, "zyx")
	core.io.println("Original: {}", vec)
	// No need to manually dereference, there's a formatter that forwards &T to
	// T, so the normal Vector formatter can be used, as it uses that formatter.
	core.io.println("Swizzled (zyx): {}", swizzles_ref)
	// Fun fact: println does something similar to swizzle to check at compile
	// time the format string. If it passes, then just uses RTTI to print the
	// values by instantiating a Formatter<T> where T is the value of the `args:
	// ...any` array (`any` type).
}
