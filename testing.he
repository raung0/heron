package main

use core.io
use core.data.vector
use core.data.heap as dheap

a += 1 + 2 * 3 + 4
a.b.c
((-(&'a &mut &'b mut +-identifier))) + 123
if my_condition { 123 }
if my_definition = 2; my_condition { 123 }
if my_condition { 123 } else { 456 } + 4
if my_condition { 123 } else if another_cond { 456 } / 4
if my_condition {
	123
} else if another_cond {
	456
} else {
	789
} * 4

for &a, b in my_iter {
}

for condition {
}

for i := mut 0; i < M; i += 1 {
	ret[i] = vector[parse_rune(format[i])]
}

a, b := 230
c, d := 230, 456

a, b, c = c, b, a

add :: fn(a, b: int) -> int do a + b

swap :: fn(using a, b: &mut int) {
	a, b = b, a
}

generic_id :: fn<'a; T: type; N: u32>(
	x: &'a T
	y: [N]T
) -> &'a T do x

throws_fn :: fn() throws core.Exception, []int; YourMum
{
	123
}

Point :: struct<T; N: usize> {
	x: T
	y: [N]T
}

Child :: struct extends Base {
}

Maybe :: union<T> {
	T
	int
}

Bits :: raw_union {
	as_u32: u32
	as_f32: f32
}

Idx :: newtype uint(0..<32)
Entities := alias [Idx]int
Adder :: alias fn(int, int) -> int

divide :: fn(a, b: f32) -> f32
	pre b != 0
	post result: result * b == a
do a / b

add :: fn<T>(a, b: T) -> T {
	return a + b
}

match &v in a {
	case int -> core.io.println("Integer: {}", v)
	case []int -> core.io.println("Integer array: {}", v)
}

ptr^.member^.function(123, 456, "hello", 'c')
ptr^.member^.empty_function()
ptr_to_slice^[123]
slice[index]
^value_im_taking_pointer_of

^p^ == ^(p^)
^p^.b^ == ^(p^.b^)
&a == &(a)

.{}

.{123, 8888, (abcd)}
.{hi}
.{hi=6, hds, yrd=3}

