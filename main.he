package main

use core
use core.io
use core.math

// The return of this cannot outlive the input vector, hence they have the same lifetime.
// Notice the ::, this is because this is a compile-time ran function.
// In the <>, lifetimes ('a'), types (T) and non-type (N, M) generic parameters are specified.
swizzle :: fn<'a; T: type; N, M: u32>(
	vector: &'a core.math.Vector<T, N>
	format: [M]rune
) -> core.math.Vector<&'a T, M>
	throws core.CompileTimeException
{
	parse_rune :: fn(r: rune) -> u32 throws core.Exception {
		match r {
		case "x" | "r" | "s" | "u" if 0 < N -> 0
		case "y" | "g" | "t" | "v" if 1 < N -> 1
		case "z" | "b" | "p"       if 2 < N -> 2
		case "w" | "a" | "q"       if 3 < N -> 3
		case -> throw core.CompileTimeException("Invalid swizzle accessor")
		}
	}

	ret := core.math.Vector<&'a T, M>()
	for i := mut 0; i < M; i++ {
		ret[i] = vector[parse_rune(format[i])]
	}
	ret
}

pub main := fn {
	vec := core.math.Vector<f32, 3>(.{1, 2, 3})
	swizzles_ref := swizzle(vec, "zyx")
	core.io.println("Original: {}", vec)
	// No need to manually dereference, there's a formatter that forwards &T to T, so the normal Vector formatter can be used, as it uses that formatter.
	core.io.println("Swizzled (zyx): {}", swizzles_ref)
	// Fun fact: println does something similar to swizzle to check at compile time the format string. If it passes, then just uses RTTI to print the values by instantiating a Formatter<T> where T is the value of the `args: ...any` array (`any` type).
}

